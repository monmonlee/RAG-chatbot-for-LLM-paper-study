- 一、為什麼把return false改成raise？raise RuntimeError會有什麼效果？ 

    - `return False`：只是丟一個布林值，程式還會繼續跑，錯誤容易被忽略。
    - `raise RuntimeError`：直接「丟出錯誤」，程式馬上停下來，告訴你哪裡出錯。


- 二、我知道try, exception基本上是避免程式錯誤後直接中斷或崩潰，但為什麼不把其他的class包在裡面而是只有環境在try, exception裡面？因為我之前的main反倒是環境在try, exception之外，其他所有的def都在裡面。 

    - `try/except`應該用在「偏I/O」的項目上，因為這些不太穩定，所以透過`try/except`可以讓系統不至於崩潰、提供替代方案。

    - 是否運用`try/except`的判斷：
        - 要包的（I/O, 外部來源, 容易出錯）：
            - 載入 API key
            - 呼叫外部 API / 其他城市或服務給的結果
            - 檔案 I/O（讀 pdf, csv, 資料庫連線…）
        - 不包的（程式邏輯）：
            - 資料清理、轉換、建立向量庫
            - 演算法邏輯（算數錯了要直接報錯，不要遮住 bug）



- 三、 `except Exception as e`:為什麼寫得這麼饒口？
    - Exception：代表捕捉所有常見錯誤。
    - as e：把錯誤存進 e 這個變數。
    - print("Setup failed:", e)：會印出錯誤訊息，例如：`Setup failed: 'OPENAI_API_KEY'


- 四、`def`可以直接`results = def_a(data)`，那`class`呢？
    - `results = class_sample(a=a, b=b)`Python 會自動去執行這個類別裡的 __init__ 方法。



- 五、什麼是「def query(self, question)」？為什麼需要對外接口？是為了之後從ui介面汲取嗎？串流原理是什麼？但如果是這樣，但是我們已經在main（）那邊有個answer = rag.query("可以跟我說關於llm的限制嗎？")之後是否需要改掉？
    - query：是一個「對外接口 (public API)」，讓別人只需要呼叫 .query("問題")，就能拿到答案，而不用管裡面 _llm_answer、ConversationalRetrievalChain 是怎麼實作的。

- 六、在`qa = ConversationalRetrievalChain.from_llm(llm=self.llm`中，我除了用定義的llm外，我其實還想加上想把溫度參數設定為0，但是這樣怎麼做？因為我是init只有規定模型版本，但沒有加上溫度?
    - 回答：將最前面改為`llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)`就好

- 七、為什麼rag = SmartRAGSystem物件，還要特別呼叫`.query()`?
    ```python
    rag = SmartRAGSystem(retriever, llm)
    answer = rag.query("可以跟我說關於llm的限制嗎？")
    print("最終答案：", answer)
    ```
    - `rag = SmartRAGSystem(retriever, llm)`rag是「物件」，被「定義」為某「類別」，在此只有定義，代表他有SmartRAGSystem裡面的行為，並沒有實施任何的功能。
    - `answer = rag.query()`則是真正動作，呼叫class裡面的`def query`
    - 那為什麼只執行`.query()`，class裡面的韓式都執行完了？
        - 因為`.query()`最後是`return self._llm_answer(question)`代表值些串接下一個方法。
        - 如果沒有任何串接，就會直接返回，其他函式都不會執行。
        - 常見的串接方法：
            - `串接模式 (chaining)`直接串接下一個函式：
                ```python
                def query(self, x):
                return self._llm_answer(x)   # 串接下一個方法
                ```
            - 彼此獨立，使用main()串連「通常一個.py會只有一個main()」:
                ```python
                def main():
                    a = rag.method_a(5)
                    b = rag.method_b(a)
                    c = rag.method_c(b)
                ```               
            - 內部呼叫模式:
                 ```python
                def b():
                    data = self.def_a()
                    return data * 2           
                ```                       

